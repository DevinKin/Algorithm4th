* 基础
1. 编写递归代码的三条原则
    - 递归总由一个最简单的情况
    - 递归调用总是去尝试解决一个规模更小的子问题,这样递归才能收敛到最简单的情况
    - 递归调用的父问题和尝试解决的子问题之间不应该有交集

2. 抽象数据类型(ADT)是一种能够使用对使用者隐藏的数据表示的数据类型.

3. 对象是能够承载数据类型的值的实体

4. 所有对象都有三大重要特性
    - 状态:数据类型中的值
    - 标识:在内存中的位置,即地址
    - 行为:数据类型的操作
    
5. Java函数参数是按值传递的,无法改变该对象的引用,但能够改变该对象的值.


6. 每个Java类都至少含有一个构造函数以创建一个对象的标识

7. Java约定equals()必须是一种等价性关系,它必须具有
    - 自反性: x.equals(x)为true
    - 对称性: 当且仅当y.equals(x)为true时,x.equals(y)返回true
    - 传递性: x.equals(y)和y.equals(x)为true,x.equals(z)也将为true
    - 它必须接受一个Object为参数并满足一下性质
        - 一致性: 当两个对象均未被修改时,反复调用x.equals(y)总是会返回相同的只
        - 非空性: x.equals(null)总是返回false
       

8. 异常: 一般用于处理不受我们控制的不可预见的错误

9. 断言: 验证我们在代码中做出的一些假设,如果表达式为false,程序将会终止并报告一条出错信息
    - 默认设置没有启用断言,可以在命令行使用`-enableassertions(-ea)`启用断言`


* 1.3 背包,队列和栈
1. 自动将一个原始数据类型转换为一个封装类型被称为自动装箱
2. 自动将一个封装类型转换为一个原始数据类型被称为自动拆箱

** 背包
1. 背包是一种不支持从中删除元素的集合数据类型
2. 它的目的就是帮助用例收集元素并迭代便利所有收集到的元素(用例也可以检查背包是否为空或者背包中的元素的数量)
3. 使用Bag说明元素的处理顺序不重要

** 先进先出队列
1. 先进先出(FIFO)队列是一种基于先进先出(FIFO)策略的集合类型.

** 下压栈
1. 下压栈是一种基于后进先出(LIFO)策略的集合类型


** 链表
1. 定义: 链表是一种递归的数据结构,它或者为空(null),或者指向一个节点(node)的引用,该节点包含有一个泛型的元素和一个指向另一条链表的引用.



* 1.4 算法分析
1. 一个程序运行的总时间主要和两点有关
    - 执行每条语句的耗时
    - 执行每条语句的频率
    
2. 从这里我们观察到的一个关键现象是最频繁的指令决定了程序执行的总时间,我们将这些指令称为程序的内循环.

3. 对于大多数程序,得到其运行时间的数学模型所需的步骤如下
    - 确定输入模型,定义问题的规模
    - 识别内循环
    - 根据内循环中的操作确定成本模型
    - 对于给定的输入,判断这些操作的执行频率.这可能需要进行数学分析
    
    
4. 增长数量级的分类
    - 常数级别
    - 对数级别: $\log(N}$
    - 线性级别
    - 线性对数级别
    - 平方级别
    - 立方级别
    - 指数级别
